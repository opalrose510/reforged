###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["Arc","ArcSeed","BridgeNode","BridgeSituation","BridgeableSituation","Choice","District","Event","Faction","Item","Location","NPC","PlayerAttribute","PlayerProfile","PlayerState","PlayerStats","Quest","Resume","Situation","Technology","WorldContext","WorldSeed",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def Arc(self) -> "ArcAst":
        return ArcAst(self)

    @property
    def ArcSeed(self) -> "ArcSeedAst":
        return ArcSeedAst(self)

    @property
    def BridgeNode(self) -> "BridgeNodeAst":
        return BridgeNodeAst(self)

    @property
    def BridgeSituation(self) -> "BridgeSituationAst":
        return BridgeSituationAst(self)

    @property
    def BridgeableSituation(self) -> "BridgeableSituationAst":
        return BridgeableSituationAst(self)

    @property
    def Choice(self) -> "ChoiceAst":
        return ChoiceAst(self)

    @property
    def District(self) -> "DistrictAst":
        return DistrictAst(self)

    @property
    def Event(self) -> "EventAst":
        return EventAst(self)

    @property
    def Faction(self) -> "FactionAst":
        return FactionAst(self)

    @property
    def Item(self) -> "ItemAst":
        return ItemAst(self)

    @property
    def Location(self) -> "LocationAst":
        return LocationAst(self)

    @property
    def NPC(self) -> "NPCAst":
        return NPCAst(self)

    @property
    def PlayerAttribute(self) -> "PlayerAttributeAst":
        return PlayerAttributeAst(self)

    @property
    def PlayerProfile(self) -> "PlayerProfileAst":
        return PlayerProfileAst(self)

    @property
    def PlayerState(self) -> "PlayerStateAst":
        return PlayerStateAst(self)

    @property
    def PlayerStats(self) -> "PlayerStatsAst":
        return PlayerStatsAst(self)

    @property
    def Quest(self) -> "QuestAst":
        return QuestAst(self)

    @property
    def Resume(self) -> "ResumeAst":
        return ResumeAst(self)

    @property
    def Situation(self) -> "SituationAst":
        return SituationAst(self)

    @property
    def Technology(self) -> "TechnologyAst":
        return TechnologyAst(self)

    @property
    def WorldContext(self) -> "WorldContextAst":
        return WorldContextAst(self)

    @property
    def WorldSeed(self) -> "WorldSeedAst":
        return WorldSeedAst(self)





class ArcAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Arc")
        self._properties: typing.Set[str] = set([ "seed",  "situations", ])
        self._props = ArcProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcProperties":
        return self._props


class ArcViewer(ArcAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def seed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("seed"))

    @property
    def situations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("situations"))

    

class ArcSeedAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ArcSeed")
        self._properties: typing.Set[str] = set([ "title",  "core_conflict",  "theme_tags",  "tone",  "factions_involved",  "internal_hint",  "internal_justification", ])
        self._props = ArcSeedProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcSeedProperties":
        return self._props


class ArcSeedViewer(ArcSeedAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcSeedProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def core_conflict(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("core_conflict"))

    @property
    def theme_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("theme_tags"))

    @property
    def tone(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tone"))

    @property
    def factions_involved(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions_involved"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class BridgeNodeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BridgeNode")
        self._properties: typing.Set[str] = set([ "source_situation_id",  "target_situation_id",  "shared_context_tags",  "shared_factions",  "shared_locations",  "shared_themes",  "internal_hint",  "internal_justification", ])
        self._props = BridgeNodeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BridgeNodeProperties":
        return self._props


class BridgeNodeViewer(BridgeNodeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BridgeNodeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def source_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_situation_id"))

    @property
    def target_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target_situation_id"))

    @property
    def shared_context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_context_tags"))

    @property
    def shared_factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_factions"))

    @property
    def shared_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_locations"))

    @property
    def shared_themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_themes"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class BridgeSituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BridgeSituation")
        self._properties: typing.Set[str] = set([ "id",  "description",  "choices",  "requirements",  "consequences",  "source_situation_ids",  "target_situation_ids",  "shared_context_tags",  "bridge_type",  "internal_hint",  "internal_justification", ])
        self._props = BridgeSituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BridgeSituationProperties":
        return self._props


class BridgeSituationViewer(BridgeSituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BridgeSituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def choices(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("choices"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def consequences(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("consequences"))

    @property
    def source_situation_ids(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_situation_ids"))

    @property
    def target_situation_ids(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target_situation_ids"))

    @property
    def shared_context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_context_tags"))

    @property
    def bridge_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bridge_type"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class BridgeableSituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BridgeableSituation")
        self._properties: typing.Set[str] = set([ "id",  "context_tags",  "factions",  "locations",  "themes",  "internal_hint",  "internal_justification", ])
        self._props = BridgeableSituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BridgeableSituationProperties":
        return self._props


class BridgeableSituationViewer(BridgeableSituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BridgeableSituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("context_tags"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("locations"))

    @property
    def themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("themes"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class ChoiceAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Choice")
        self._properties: typing.Set[str] = set([ "id",  "text",  "requirements",  "attributes_gained",  "attributes_lost",  "stat_changes",  "next_situation_id",  "internal_hint",  "internal_justification", ])
        self._props = ChoiceProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChoiceProperties":
        return self._props


class ChoiceViewer(ChoiceAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChoiceProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("text"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def attributes_gained(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes_gained"))

    @property
    def attributes_lost(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes_lost"))

    @property
    def stat_changes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_changes"))

    @property
    def next_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_situation_id"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class DistrictAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("District")
        self._properties: typing.Set[str] = set([ "id",  "traits",  "hazards",  "factions",  "description",  "internal_hint",  "internal_justification", ])
        self._props = DistrictProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DistrictProperties":
        return self._props


class DistrictViewer(DistrictAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DistrictProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("traits"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class EventAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Event")
        self._properties: typing.Set[str] = set([ "id",  "title",  "description",  "type",  "triggers",  "consequences",  "affected_npcs",  "affected_locations",  "internal_hint",  "internal_justification", ])
        self._props = EventProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EventProperties":
        return self._props


class EventViewer(EventAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EventProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def triggers(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("triggers"))

    @property
    def consequences(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("consequences"))

    @property
    def affected_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("affected_npcs"))

    @property
    def affected_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("affected_locations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class FactionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Faction")
        self._properties: typing.Set[str] = set([ "name",  "ideology",  "territory",  "influence_level",  "relationships",  "internal_hint",  "internal_justification", ])
        self._props = FactionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FactionProperties":
        return self._props


class FactionViewer(FactionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FactionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def ideology(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("ideology"))

    @property
    def territory(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("territory"))

    @property
    def influence_level(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("influence_level"))

    @property
    def relationships(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relationships"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class ItemAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Item")
        self._properties: typing.Set[str] = set([ "id",  "name",  "type",  "description",  "effects",  "requirements",  "rarity",  "internal_hint",  "internal_justification", ])
        self._props = ItemProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ItemProperties":
        return self._props


class ItemViewer(ItemAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ItemProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def effects(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("effects"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def rarity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rarity"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class LocationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Location")
        self._properties: typing.Set[str] = set([ "id",  "name",  "type",  "description",  "traits",  "hazards",  "connected_locations",  "npcs_present",  "internal_hint",  "internal_justification", ])
        self._props = LocationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LocationProperties":
        return self._props


class LocationViewer(LocationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class LocationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("traits"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def connected_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("connected_locations"))

    @property
    def npcs_present(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("npcs_present"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class NPCAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NPC")
        self._properties: typing.Set[str] = set([ "id",  "name",  "role",  "description",  "personality_traits",  "relationships",  "faction_affiliations",  "location_id",  "internal_hint",  "internal_justification", ])
        self._props = NPCProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NPCProperties":
        return self._props


class NPCViewer(NPCAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class NPCProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def role(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("role"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def personality_traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("personality_traits"))

    @property
    def relationships(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relationships"))

    @property
    def faction_affiliations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("faction_affiliations"))

    @property
    def location_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("location_id"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class PlayerAttributeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerAttribute")
        self._properties: typing.Set[str] = set([ "id",  "type",  "description",  "stat_mods", ])
        self._props = PlayerAttributeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerAttributeProperties":
        return self._props


class PlayerAttributeViewer(PlayerAttributeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerAttributeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def stat_mods(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_mods"))

    

class PlayerProfileAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerProfile")
        self._properties: typing.Set[str] = set([ "narrative_summary",  "key_traits",  "background_hints", ])
        self._props = PlayerProfileProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerProfileProperties":
        return self._props


class PlayerProfileViewer(PlayerProfileAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerProfileProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def narrative_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("narrative_summary"))

    @property
    def key_traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_traits"))

    @property
    def background_hints(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("background_hints"))

    

class PlayerStateAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerState")
        self._properties: typing.Set[str] = set([ "name",  "stats",  "attributes",  "profile",  "history", ])
        self._props = PlayerStateProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerStateProperties":
        return self._props


class PlayerStateViewer(PlayerStateAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerStateProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def stats(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stats"))

    @property
    def attributes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes"))

    @property
    def profile(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("profile"))

    @property
    def history(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("history"))

    

class PlayerStatsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerStats")
        self._properties: typing.Set[str] = set([ "might",  "insight",  "nimbleness",  "destiny",  "savvy",  "expertise",  "tenacity",  "station",  "opulence",  "celebrity",  "integrity",  "allure",  "lineage", ])
        self._props = PlayerStatsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerStatsProperties":
        return self._props


class PlayerStatsViewer(PlayerStatsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerStatsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def might(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("might"))

    @property
    def insight(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("insight"))

    @property
    def nimbleness(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("nimbleness"))

    @property
    def destiny(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("destiny"))

    @property
    def savvy(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("savvy"))

    @property
    def expertise(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expertise"))

    @property
    def tenacity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tenacity"))

    @property
    def station(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("station"))

    @property
    def opulence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("opulence"))

    @property
    def celebrity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("celebrity"))

    @property
    def integrity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("integrity"))

    @property
    def allure(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("allure"))

    @property
    def lineage(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lineage"))

    

class QuestAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Quest")
        self._properties: typing.Set[str] = set([ "id",  "title",  "description",  "type",  "objectives",  "rewards",  "requirements",  "related_npcs",  "related_locations",  "internal_hint",  "internal_justification", ])
        self._props = QuestProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QuestProperties":
        return self._props


class QuestViewer(QuestAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QuestProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def objectives(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("objectives"))

    @property
    def rewards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rewards"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def related_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("related_npcs"))

    @property
    def related_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("related_locations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class ResumeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Resume")
        self._properties: typing.Set[str] = set([ "name",  "email",  "experience",  "skills", ])
        self._props = ResumeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResumeProperties":
        return self._props


class ResumeViewer(ResumeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResumeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def email(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("email"))

    @property
    def experience(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("experience"))

    @property
    def skills(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("skills"))

    

class SituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Situation")
        self._properties: typing.Set[str] = set([ "id",  "description",  "choices",  "requirements",  "consequences",  "bridgeable",  "context_tags",  "arc_outcome",  "internal_hint",  "internal_justification", ])
        self._props = SituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SituationProperties":
        return self._props


class SituationViewer(SituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def choices(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("choices"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def consequences(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("consequences"))

    @property
    def bridgeable(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bridgeable"))

    @property
    def context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("context_tags"))

    @property
    def arc_outcome(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("arc_outcome"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class TechnologyAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Technology")
        self._properties: typing.Set[str] = set([ "name",  "description",  "impact",  "limitations",  "internal_hint",  "internal_justification", ])
        self._props = TechnologyProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TechnologyProperties":
        return self._props


class TechnologyViewer(TechnologyAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TechnologyProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def impact(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("impact"))

    @property
    def limitations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("limitations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class WorldContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorldContext")
        self._properties: typing.Set[str] = set([ "seed",  "technologies",  "factions",  "districts",  "npcs",  "tension_sliders",  "world_root", ])
        self._props = WorldContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorldContextProperties":
        return self._props


class WorldContextViewer(WorldContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorldContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def seed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("seed"))

    @property
    def technologies(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("technologies"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def districts(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("districts"))

    @property
    def npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("npcs"))

    @property
    def tension_sliders(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tension_sliders"))

    @property
    def world_root(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("world_root"))

    

class WorldSeedAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorldSeed")
        self._properties: typing.Set[str] = set([ "name",  "themes",  "high_concept",  "internal_hint",  "internal_justification", ])
        self._props = WorldSeedProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorldSeedProperties":
        return self._props


class WorldSeedViewer(WorldSeedAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorldSeedProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("themes"))

    @property
    def high_concept(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("high_concept"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    




__all__ = ["TypeBuilder"]