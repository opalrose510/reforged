###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["ActionAndReasoning","Arc","ArcOutcome","ArcSeed","Choice","CreateArc","CreateArcOutcome","CreateChoices","CreateFaction","CreateMultipleSituations","CreateNPC","CreateSituation","CreateTechnology","District","DownOneLevel","Event","Faction","FindMissingSituations","GetSituationById","GoToArcRoot","GoToSituation","GoToWorldRoot","IdentifyNarrativeGaps","Item","JoinSituationOutput","Location","NPC","PlayerAttribute","PlayerProfile","PlayerState","PlayerStats","Quest","Resume","ShortActionAndReasoning","Situation","StatDescriptors","StatRequirement","Technology","UpOneLevel","WorldContext","WorldSeed",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def ActionAndReasoning(self) -> "ActionAndReasoningAst":
        return ActionAndReasoningAst(self)

    @property
    def Arc(self) -> "ArcAst":
        return ArcAst(self)

    @property
    def ArcOutcome(self) -> "ArcOutcomeAst":
        return ArcOutcomeAst(self)

    @property
    def ArcSeed(self) -> "ArcSeedAst":
        return ArcSeedAst(self)

    @property
    def Choice(self) -> "ChoiceAst":
        return ChoiceAst(self)

    @property
    def CreateArc(self) -> "CreateArcAst":
        return CreateArcAst(self)

    @property
    def CreateArcOutcome(self) -> "CreateArcOutcomeAst":
        return CreateArcOutcomeAst(self)

    @property
    def CreateChoices(self) -> "CreateChoicesAst":
        return CreateChoicesAst(self)

    @property
    def CreateFaction(self) -> "CreateFactionAst":
        return CreateFactionAst(self)

    @property
    def CreateMultipleSituations(self) -> "CreateMultipleSituationsAst":
        return CreateMultipleSituationsAst(self)

    @property
    def CreateNPC(self) -> "CreateNPCAst":
        return CreateNPCAst(self)

    @property
    def CreateSituation(self) -> "CreateSituationAst":
        return CreateSituationAst(self)

    @property
    def CreateTechnology(self) -> "CreateTechnologyAst":
        return CreateTechnologyAst(self)

    @property
    def District(self) -> "DistrictAst":
        return DistrictAst(self)

    @property
    def DownOneLevel(self) -> "DownOneLevelAst":
        return DownOneLevelAst(self)

    @property
    def Event(self) -> "EventAst":
        return EventAst(self)

    @property
    def Faction(self) -> "FactionAst":
        return FactionAst(self)

    @property
    def FindMissingSituations(self) -> "FindMissingSituationsAst":
        return FindMissingSituationsAst(self)

    @property
    def GetSituationById(self) -> "GetSituationByIdAst":
        return GetSituationByIdAst(self)

    @property
    def GoToArcRoot(self) -> "GoToArcRootAst":
        return GoToArcRootAst(self)

    @property
    def GoToSituation(self) -> "GoToSituationAst":
        return GoToSituationAst(self)

    @property
    def GoToWorldRoot(self) -> "GoToWorldRootAst":
        return GoToWorldRootAst(self)

    @property
    def IdentifyNarrativeGaps(self) -> "IdentifyNarrativeGapsAst":
        return IdentifyNarrativeGapsAst(self)

    @property
    def Item(self) -> "ItemAst":
        return ItemAst(self)

    @property
    def JoinSituationOutput(self) -> "JoinSituationOutputAst":
        return JoinSituationOutputAst(self)

    @property
    def Location(self) -> "LocationAst":
        return LocationAst(self)

    @property
    def NPC(self) -> "NPCAst":
        return NPCAst(self)

    @property
    def PlayerAttribute(self) -> "PlayerAttributeAst":
        return PlayerAttributeAst(self)

    @property
    def PlayerProfile(self) -> "PlayerProfileAst":
        return PlayerProfileAst(self)

    @property
    def PlayerState(self) -> "PlayerStateAst":
        return PlayerStateAst(self)

    @property
    def PlayerStats(self) -> "PlayerStatsAst":
        return PlayerStatsAst(self)

    @property
    def Quest(self) -> "QuestAst":
        return QuestAst(self)

    @property
    def Resume(self) -> "ResumeAst":
        return ResumeAst(self)

    @property
    def ShortActionAndReasoning(self) -> "ShortActionAndReasoningAst":
        return ShortActionAndReasoningAst(self)

    @property
    def Situation(self) -> "SituationAst":
        return SituationAst(self)

    @property
    def StatDescriptors(self) -> "StatDescriptorsAst":
        return StatDescriptorsAst(self)

    @property
    def StatRequirement(self) -> "StatRequirementAst":
        return StatRequirementAst(self)

    @property
    def Technology(self) -> "TechnologyAst":
        return TechnologyAst(self)

    @property
    def UpOneLevel(self) -> "UpOneLevelAst":
        return UpOneLevelAst(self)

    @property
    def WorldContext(self) -> "WorldContextAst":
        return WorldContextAst(self)

    @property
    def WorldSeed(self) -> "WorldSeedAst":
        return WorldSeedAst(self)





class ActionAndReasoningAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionAndReasoning")
        self._properties: typing.Set[str] = set([ "action",  "generated_description",  "reasoning", ])
        self._props = ActionAndReasoningProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionAndReasoningProperties":
        return self._props


class ActionAndReasoningViewer(ActionAndReasoningAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ActionAndReasoningProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def action(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("action"))

    @property
    def generated_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_description"))

    @property
    def reasoning(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reasoning"))

    

class ArcAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Arc")
        self._properties: typing.Set[str] = set([ "seed",  "situations",  "outcomes", ])
        self._props = ArcProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcProperties":
        return self._props


class ArcViewer(ArcAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def seed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("seed"))

    @property
    def situations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("situations"))

    @property
    def outcomes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("outcomes"))

    

class ArcOutcomeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ArcOutcome")
        self._properties: typing.Set[str] = set([ "id",  "description",  "internal_hint",  "internal_justification",  "tags",  "estimated_duration", ])
        self._props = ArcOutcomeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcOutcomeProperties":
        return self._props


class ArcOutcomeViewer(ArcOutcomeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcOutcomeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    @property
    def tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tags"))

    @property
    def estimated_duration(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("estimated_duration"))

    

class ArcSeedAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ArcSeed")
        self._properties: typing.Set[str] = set([ "title",  "core_conflict",  "theme_tags",  "tone",  "factions_involved",  "internal_hint",  "internal_justification", ])
        self._props = ArcSeedProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcSeedProperties":
        return self._props


class ArcSeedViewer(ArcSeedAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcSeedProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def core_conflict(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("core_conflict"))

    @property
    def theme_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("theme_tags"))

    @property
    def tone(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tone"))

    @property
    def factions_involved(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions_involved"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class ChoiceAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Choice")
        self._properties: typing.Set[str] = set([ "id",  "text",  "dialogue_response",  "choice_type",  "emotional_tone",  "body_language",  "requirements",  "attributes_gained",  "attributes_lost",  "stat_changes",  "next_situation_id",  "internal_hint",  "internal_justification",  "new_npcs",  "new_factions",  "new_technologies", ])
        self._props = ChoiceProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChoiceProperties":
        return self._props


class ChoiceViewer(ChoiceAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChoiceProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("text"))

    @property
    def dialogue_response(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("dialogue_response"))

    @property
    def choice_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("choice_type"))

    @property
    def emotional_tone(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("emotional_tone"))

    @property
    def body_language(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("body_language"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def attributes_gained(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes_gained"))

    @property
    def attributes_lost(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes_lost"))

    @property
    def stat_changes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_changes"))

    @property
    def next_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_situation_id"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    @property
    def new_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("new_npcs"))

    @property
    def new_factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("new_factions"))

    @property
    def new_technologies(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("new_technologies"))

    

class CreateArcAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateArc")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_arc", ])
        self._props = CreateArcProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateArcProperties":
        return self._props


class CreateArcViewer(CreateArcAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateArcProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_arc(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_arc"))

    

class CreateArcOutcomeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateArcOutcome")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_arc_outcome", ])
        self._props = CreateArcOutcomeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateArcOutcomeProperties":
        return self._props


class CreateArcOutcomeViewer(CreateArcOutcomeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateArcOutcomeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_arc_outcome(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_arc_outcome"))

    

class CreateChoicesAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateChoices")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_choices", ])
        self._props = CreateChoicesProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateChoicesProperties":
        return self._props


class CreateChoicesViewer(CreateChoicesAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateChoicesProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_choices(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_choices"))

    

class CreateFactionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateFaction")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_faction", ])
        self._props = CreateFactionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateFactionProperties":
        return self._props


class CreateFactionViewer(CreateFactionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateFactionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_faction(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_faction"))

    

class CreateMultipleSituationsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateMultipleSituations")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_situations", ])
        self._props = CreateMultipleSituationsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateMultipleSituationsProperties":
        return self._props


class CreateMultipleSituationsViewer(CreateMultipleSituationsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateMultipleSituationsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_situations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_situations"))

    

class CreateNPCAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateNPC")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_npc", ])
        self._props = CreateNPCProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateNPCProperties":
        return self._props


class CreateNPCViewer(CreateNPCAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateNPCProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_npc(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_npc"))

    

class CreateSituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateSituation")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_situation", ])
        self._props = CreateSituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateSituationProperties":
        return self._props


class CreateSituationViewer(CreateSituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateSituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_situation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_situation"))

    

class CreateTechnologyAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateTechnology")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "generated_technology", ])
        self._props = CreateTechnologyProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateTechnologyProperties":
        return self._props


class CreateTechnologyViewer(CreateTechnologyAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CreateTechnologyProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def generated_technology(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_technology"))

    

class DistrictAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("District")
        self._properties: typing.Set[str] = set([ "id",  "traits",  "hazards",  "factions",  "description",  "internal_hint",  "internal_justification", ])
        self._props = DistrictProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DistrictProperties":
        return self._props


class DistrictViewer(DistrictAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DistrictProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("traits"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class DownOneLevelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DownOneLevel")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason", ])
        self._props = DownOneLevelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DownOneLevelProperties":
        return self._props


class DownOneLevelViewer(DownOneLevelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DownOneLevelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    

class EventAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Event")
        self._properties: typing.Set[str] = set([ "id",  "title",  "description",  "type",  "triggers",  "consequences",  "affected_npcs",  "affected_locations",  "internal_hint",  "internal_justification", ])
        self._props = EventProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EventProperties":
        return self._props


class EventViewer(EventAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EventProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def triggers(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("triggers"))

    @property
    def consequences(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("consequences"))

    @property
    def affected_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("affected_npcs"))

    @property
    def affected_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("affected_locations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class FactionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Faction")
        self._properties: typing.Set[str] = set([ "name",  "description",  "ideology",  "location",  "influence_level",  "relationships",  "hazards",  "internal_hint",  "internal_justification", ])
        self._props = FactionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FactionProperties":
        return self._props


class FactionViewer(FactionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FactionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def ideology(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("ideology"))

    @property
    def location(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("location"))

    @property
    def influence_level(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("influence_level"))

    @property
    def relationships(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relationships"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class FindMissingSituationsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FindMissingSituations")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "missing_situations", ])
        self._props = FindMissingSituationsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FindMissingSituationsProperties":
        return self._props


class FindMissingSituationsViewer(FindMissingSituationsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FindMissingSituationsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def missing_situations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("missing_situations"))

    

class GetSituationByIdAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GetSituationById")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "situation_id", ])
        self._props = GetSituationByIdProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GetSituationByIdProperties":
        return self._props


class GetSituationByIdViewer(GetSituationByIdAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GetSituationByIdProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("situation_id"))

    

class GoToArcRootAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoToArcRoot")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason", ])
        self._props = GoToArcRootProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoToArcRootProperties":
        return self._props


class GoToArcRootViewer(GoToArcRootAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GoToArcRootProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    

class GoToSituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoToSituation")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "situation_id", ])
        self._props = GoToSituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoToSituationProperties":
        return self._props


class GoToSituationViewer(GoToSituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GoToSituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("situation_id"))

    

class GoToWorldRootAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoToWorldRoot")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason", ])
        self._props = GoToWorldRootProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoToWorldRootProperties":
        return self._props


class GoToWorldRootViewer(GoToWorldRootAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GoToWorldRootProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    

class IdentifyNarrativeGapsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IdentifyNarrativeGaps")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason",  "narrative_gaps", ])
        self._props = IdentifyNarrativeGapsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IdentifyNarrativeGapsProperties":
        return self._props


class IdentifyNarrativeGapsViewer(IdentifyNarrativeGapsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class IdentifyNarrativeGapsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def narrative_gaps(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("narrative_gaps"))

    

class ItemAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Item")
        self._properties: typing.Set[str] = set([ "id",  "name",  "type",  "description",  "effects",  "requirements",  "rarity",  "internal_hint",  "internal_justification", ])
        self._props = ItemProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ItemProperties":
        return self._props


class ItemViewer(ItemAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ItemProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def effects(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("effects"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def rarity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rarity"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class JoinSituationOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("JoinSituationOutput")
        self._properties: typing.Set[str] = set([ "from_situation_id",  "to_situation_id",  "reason",  "choice", ])
        self._props = JoinSituationOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "JoinSituationOutputProperties":
        return self._props


class JoinSituationOutputViewer(JoinSituationOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class JoinSituationOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def from_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("from_situation_id"))

    @property
    def to_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("to_situation_id"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def choice(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("choice"))

    

class LocationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Location")
        self._properties: typing.Set[str] = set([ "id",  "name",  "type",  "description",  "traits",  "hazards",  "connected_locations",  "npcs_present",  "internal_hint",  "internal_justification", ])
        self._props = LocationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LocationProperties":
        return self._props


class LocationViewer(LocationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class LocationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("traits"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def connected_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("connected_locations"))

    @property
    def npcs_present(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("npcs_present"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class NPCAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NPC")
        self._properties: typing.Set[str] = set([ "id",  "name",  "role",  "description",  "personality_traits",  "relationships",  "faction_affiliations",  "location_id",  "internal_hint",  "internal_justification", ])
        self._props = NPCProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NPCProperties":
        return self._props


class NPCViewer(NPCAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class NPCProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def role(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("role"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def personality_traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("personality_traits"))

    @property
    def relationships(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relationships"))

    @property
    def faction_affiliations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("faction_affiliations"))

    @property
    def location_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("location_id"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class PlayerAttributeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerAttribute")
        self._properties: typing.Set[str] = set([ "id",  "type",  "description",  "stat_mods", ])
        self._props = PlayerAttributeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerAttributeProperties":
        return self._props


class PlayerAttributeViewer(PlayerAttributeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerAttributeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def stat_mods(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_mods"))

    

class PlayerProfileAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerProfile")
        self._properties: typing.Set[str] = set([ "narrative_summary",  "key_traits",  "background_hints", ])
        self._props = PlayerProfileProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerProfileProperties":
        return self._props


class PlayerProfileViewer(PlayerProfileAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerProfileProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def narrative_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("narrative_summary"))

    @property
    def key_traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_traits"))

    @property
    def background_hints(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("background_hints"))

    

class PlayerStateAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerState")
        self._properties: typing.Set[str] = set([ "name",  "stats",  "attributes",  "profile",  "history", ])
        self._props = PlayerStateProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerStateProperties":
        return self._props


class PlayerStateViewer(PlayerStateAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerStateProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def stats(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stats"))

    @property
    def attributes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes"))

    @property
    def profile(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("profile"))

    @property
    def history(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("history"))

    

class PlayerStatsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerStats")
        self._properties: typing.Set[str] = set([ "might",  "insight",  "nimbleness",  "destiny",  "savvy",  "expertise",  "tenacity",  "station",  "opulence",  "celebrity",  "integrity",  "allure",  "lineage", ])
        self._props = PlayerStatsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerStatsProperties":
        return self._props


class PlayerStatsViewer(PlayerStatsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerStatsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def might(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("might"))

    @property
    def insight(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("insight"))

    @property
    def nimbleness(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("nimbleness"))

    @property
    def destiny(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("destiny"))

    @property
    def savvy(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("savvy"))

    @property
    def expertise(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expertise"))

    @property
    def tenacity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tenacity"))

    @property
    def station(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("station"))

    @property
    def opulence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("opulence"))

    @property
    def celebrity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("celebrity"))

    @property
    def integrity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("integrity"))

    @property
    def allure(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("allure"))

    @property
    def lineage(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lineage"))

    

class QuestAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Quest")
        self._properties: typing.Set[str] = set([ "id",  "title",  "description",  "type",  "objectives",  "rewards",  "requirements",  "related_npcs",  "related_locations",  "internal_hint",  "internal_justification", ])
        self._props = QuestProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QuestProperties":
        return self._props


class QuestViewer(QuestAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QuestProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def objectives(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("objectives"))

    @property
    def rewards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rewards"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def related_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("related_npcs"))

    @property
    def related_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("related_locations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class ResumeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Resume")
        self._properties: typing.Set[str] = set([ "name",  "email",  "experience",  "skills", ])
        self._props = ResumeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResumeProperties":
        return self._props


class ResumeViewer(ResumeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResumeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def email(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("email"))

    @property
    def experience(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("experience"))

    @property
    def skills(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("skills"))

    

class ShortActionAndReasoningAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ShortActionAndReasoning")
        self._properties: typing.Set[str] = set([ "action",  "generated_description",  "reasoning", ])
        self._props = ShortActionAndReasoningProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ShortActionAndReasoningProperties":
        return self._props


class ShortActionAndReasoningViewer(ShortActionAndReasoningAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ShortActionAndReasoningProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def action(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("action"))

    @property
    def generated_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generated_description"))

    @property
    def reasoning(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reasoning"))

    

class SituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Situation")
        self._properties: typing.Set[str] = set([ "id",  "description",  "player_perspective_description",  "choices",  "stat_requirements",  "bridgeable",  "context_tags",  "internal_hint",  "internal_justification", ])
        self._props = SituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SituationProperties":
        return self._props


class SituationViewer(SituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def player_perspective_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("player_perspective_description"))

    @property
    def choices(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("choices"))

    @property
    def stat_requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_requirements"))

    @property
    def bridgeable(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bridgeable"))

    @property
    def context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("context_tags"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class StatDescriptorsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StatDescriptors")
        self._properties: typing.Set[str] = set([ "might_descriptors",  "insight_descriptors",  "nimbleness_descriptors",  "destiny_descriptors",  "savvy_descriptors",  "expertise_descriptors",  "tenacity_descriptors",  "station_descriptors",  "opulence_descriptors",  "celebrity_descriptors",  "integrity_descriptors",  "allure_descriptors",  "lineage_descriptors", ])
        self._props = StatDescriptorsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StatDescriptorsProperties":
        return self._props


class StatDescriptorsViewer(StatDescriptorsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StatDescriptorsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def might_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("might_descriptors"))

    @property
    def insight_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("insight_descriptors"))

    @property
    def nimbleness_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("nimbleness_descriptors"))

    @property
    def destiny_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("destiny_descriptors"))

    @property
    def savvy_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("savvy_descriptors"))

    @property
    def expertise_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expertise_descriptors"))

    @property
    def tenacity_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tenacity_descriptors"))

    @property
    def station_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("station_descriptors"))

    @property
    def opulence_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("opulence_descriptors"))

    @property
    def celebrity_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("celebrity_descriptors"))

    @property
    def integrity_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("integrity_descriptors"))

    @property
    def allure_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("allure_descriptors"))

    @property
    def lineage_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lineage_descriptors"))

    

class StatRequirementAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StatRequirement")
        self._properties: typing.Set[str] = set([ "attribute_name",  "min_value", ])
        self._props = StatRequirementProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StatRequirementProperties":
        return self._props


class StatRequirementViewer(StatRequirementAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StatRequirementProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def attribute_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attribute_name"))

    @property
    def min_value(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("min_value"))

    

class TechnologyAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Technology")
        self._properties: typing.Set[str] = set([ "name",  "description",  "impact",  "limitations",  "hazards",  "factions",  "traits",  "internal_hint",  "internal_justification", ])
        self._props = TechnologyProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TechnologyProperties":
        return self._props


class TechnologyViewer(TechnologyAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TechnologyProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def impact(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("impact"))

    @property
    def limitations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("limitations"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("traits"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class UpOneLevelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpOneLevel")
        self._properties: typing.Set[str] = set([ "tool_name",  "reason", ])
        self._props = UpOneLevelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpOneLevelProperties":
        return self._props


class UpOneLevelViewer(UpOneLevelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class UpOneLevelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    

class WorldContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorldContext")
        self._properties: typing.Set[str] = set([ "seed",  "technologies",  "factions",  "districts",  "npcs",  "tension_sliders",  "world_root", ])
        self._props = WorldContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorldContextProperties":
        return self._props


class WorldContextViewer(WorldContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorldContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def seed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("seed"))

    @property
    def technologies(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("technologies"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def districts(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("districts"))

    @property
    def npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("npcs"))

    @property
    def tension_sliders(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tension_sliders"))

    @property
    def world_root(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("world_root"))

    

class WorldSeedAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorldSeed")
        self._properties: typing.Set[str] = set([ "name",  "themes",  "high_concept",  "internal_hint",  "internal_justification", ])
        self._props = WorldSeedProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorldSeedProperties":
        return self._props


class WorldSeedViewer(WorldSeedAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorldSeedProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("themes"))

    @property
    def high_concept(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("high_concept"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    




__all__ = ["TypeBuilder"]