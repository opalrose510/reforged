###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["Arc","ArcOutcome","ArcSeed","BridgeNode","BridgeableSituation","Choice","CompressedWorldContext","ConceptSummary","District","Event","Faction","GetDistrictDetails","GetFactionDetails","GetNPCDetails","GetTechnologyDetails","Item","Location","NPC","PlayerAttribute","PlayerProfile","PlayerState","PlayerStats","Quest","Resume","Situation","StatDescriptors","StatRequirement","Technology","WorldConceptTool","WorldContext","WorldSeed",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def Arc(self) -> "ArcAst":
        return ArcAst(self)

    @property
    def ArcOutcome(self) -> "ArcOutcomeAst":
        return ArcOutcomeAst(self)

    @property
    def ArcSeed(self) -> "ArcSeedAst":
        return ArcSeedAst(self)

    @property
    def BridgeNode(self) -> "BridgeNodeAst":
        return BridgeNodeAst(self)

    @property
    def BridgeableSituation(self) -> "BridgeableSituationAst":
        return BridgeableSituationAst(self)

    @property
    def Choice(self) -> "ChoiceAst":
        return ChoiceAst(self)

    @property
    def CompressedWorldContext(self) -> "CompressedWorldContextAst":
        return CompressedWorldContextAst(self)

    @property
    def ConceptSummary(self) -> "ConceptSummaryAst":
        return ConceptSummaryAst(self)

    @property
    def District(self) -> "DistrictAst":
        return DistrictAst(self)

    @property
    def Event(self) -> "EventAst":
        return EventAst(self)

    @property
    def Faction(self) -> "FactionAst":
        return FactionAst(self)

    @property
    def GetDistrictDetails(self) -> "GetDistrictDetailsAst":
        return GetDistrictDetailsAst(self)

    @property
    def GetFactionDetails(self) -> "GetFactionDetailsAst":
        return GetFactionDetailsAst(self)

    @property
    def GetNPCDetails(self) -> "GetNPCDetailsAst":
        return GetNPCDetailsAst(self)

    @property
    def GetTechnologyDetails(self) -> "GetTechnologyDetailsAst":
        return GetTechnologyDetailsAst(self)

    @property
    def Item(self) -> "ItemAst":
        return ItemAst(self)

    @property
    def Location(self) -> "LocationAst":
        return LocationAst(self)

    @property
    def NPC(self) -> "NPCAst":
        return NPCAst(self)

    @property
    def PlayerAttribute(self) -> "PlayerAttributeAst":
        return PlayerAttributeAst(self)

    @property
    def PlayerProfile(self) -> "PlayerProfileAst":
        return PlayerProfileAst(self)

    @property
    def PlayerState(self) -> "PlayerStateAst":
        return PlayerStateAst(self)

    @property
    def PlayerStats(self) -> "PlayerStatsAst":
        return PlayerStatsAst(self)

    @property
    def Quest(self) -> "QuestAst":
        return QuestAst(self)

    @property
    def Resume(self) -> "ResumeAst":
        return ResumeAst(self)

    @property
    def Situation(self) -> "SituationAst":
        return SituationAst(self)

    @property
    def StatDescriptors(self) -> "StatDescriptorsAst":
        return StatDescriptorsAst(self)

    @property
    def StatRequirement(self) -> "StatRequirementAst":
        return StatRequirementAst(self)

    @property
    def Technology(self) -> "TechnologyAst":
        return TechnologyAst(self)

    @property
    def WorldConceptTool(self) -> "WorldConceptToolAst":
        return WorldConceptToolAst(self)

    @property
    def WorldContext(self) -> "WorldContextAst":
        return WorldContextAst(self)

    @property
    def WorldSeed(self) -> "WorldSeedAst":
        return WorldSeedAst(self)





class ArcAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Arc")
        self._properties: typing.Set[str] = set([ "seed",  "situations",  "outcomes", ])
        self._props = ArcProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcProperties":
        return self._props


class ArcViewer(ArcAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def seed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("seed"))

    @property
    def situations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("situations"))

    @property
    def outcomes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("outcomes"))

    

class ArcOutcomeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ArcOutcome")
        self._properties: typing.Set[str] = set([ "id",  "description",  "internal_hint",  "internal_justification",  "tags",  "estimated_duration", ])
        self._props = ArcOutcomeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcOutcomeProperties":
        return self._props


class ArcOutcomeViewer(ArcOutcomeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcOutcomeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    @property
    def tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tags"))

    @property
    def estimated_duration(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("estimated_duration"))

    

class ArcSeedAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ArcSeed")
        self._properties: typing.Set[str] = set([ "title",  "core_conflict",  "theme_tags",  "tone",  "factions_involved",  "internal_hint",  "internal_justification", ])
        self._props = ArcSeedProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArcSeedProperties":
        return self._props


class ArcSeedViewer(ArcSeedAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArcSeedProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def core_conflict(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("core_conflict"))

    @property
    def theme_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("theme_tags"))

    @property
    def tone(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tone"))

    @property
    def factions_involved(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions_involved"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class BridgeNodeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BridgeNode")
        self._properties: typing.Set[str] = set([ "source_situation_id",  "target_situation_id",  "shared_context_tags",  "shared_factions",  "shared_locations",  "shared_themes",  "internal_hint",  "internal_justification", ])
        self._props = BridgeNodeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BridgeNodeProperties":
        return self._props


class BridgeNodeViewer(BridgeNodeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BridgeNodeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def source_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_situation_id"))

    @property
    def target_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target_situation_id"))

    @property
    def shared_context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_context_tags"))

    @property
    def shared_factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_factions"))

    @property
    def shared_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_locations"))

    @property
    def shared_themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_themes"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class BridgeableSituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BridgeableSituation")
        self._properties: typing.Set[str] = set([ "id",  "context_tags",  "factions",  "locations",  "themes",  "internal_hint",  "internal_justification", ])
        self._props = BridgeableSituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BridgeableSituationProperties":
        return self._props


class BridgeableSituationViewer(BridgeableSituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BridgeableSituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("context_tags"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("locations"))

    @property
    def themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("themes"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class ChoiceAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Choice")
        self._properties: typing.Set[str] = set([ "id",  "text",  "dialogue_response",  "choice_type",  "player_perspective",  "emotional_tone",  "body_language",  "requirements",  "attributes_gained",  "attributes_lost",  "stat_changes",  "next_situation_id",  "internal_hint",  "internal_justification",  "new_npcs",  "new_factions",  "new_technologies", ])
        self._props = ChoiceProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChoiceProperties":
        return self._props


class ChoiceViewer(ChoiceAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChoiceProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("text"))

    @property
    def dialogue_response(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("dialogue_response"))

    @property
    def choice_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("choice_type"))

    @property
    def player_perspective(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("player_perspective"))

    @property
    def emotional_tone(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("emotional_tone"))

    @property
    def body_language(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("body_language"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def attributes_gained(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes_gained"))

    @property
    def attributes_lost(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes_lost"))

    @property
    def stat_changes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_changes"))

    @property
    def next_situation_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_situation_id"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    @property
    def new_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("new_npcs"))

    @property
    def new_factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("new_factions"))

    @property
    def new_technologies(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("new_technologies"))

    

class CompressedWorldContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CompressedWorldContext")
        self._properties: typing.Set[str] = set([ "seed",  "concept_summaries",  "tension_sliders", ])
        self._props = CompressedWorldContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CompressedWorldContextProperties":
        return self._props


class CompressedWorldContextViewer(CompressedWorldContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CompressedWorldContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def seed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("seed"))

    @property
    def concept_summaries(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("concept_summaries"))

    @property
    def tension_sliders(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tension_sliders"))

    

class ConceptSummaryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ConceptSummary")
        self._properties: typing.Set[str] = set([ "id",  "name",  "type",  "short_description", ])
        self._props = ConceptSummaryProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ConceptSummaryProperties":
        return self._props


class ConceptSummaryViewer(ConceptSummaryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ConceptSummaryProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def short_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("short_description"))

    

class DistrictAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("District")
        self._properties: typing.Set[str] = set([ "id",  "traits",  "hazards",  "factions",  "description",  "internal_hint",  "internal_justification", ])
        self._props = DistrictProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DistrictProperties":
        return self._props


class DistrictViewer(DistrictAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DistrictProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("traits"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class EventAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Event")
        self._properties: typing.Set[str] = set([ "id",  "title",  "description",  "type",  "triggers",  "consequences",  "affected_npcs",  "affected_locations",  "internal_hint",  "internal_justification", ])
        self._props = EventProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EventProperties":
        return self._props


class EventViewer(EventAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EventProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def triggers(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("triggers"))

    @property
    def consequences(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("consequences"))

    @property
    def affected_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("affected_npcs"))

    @property
    def affected_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("affected_locations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class FactionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Faction")
        self._properties: typing.Set[str] = set([ "name",  "ideology",  "territory",  "influence_level",  "relationships",  "internal_hint",  "internal_justification", ])
        self._props = FactionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FactionProperties":
        return self._props


class FactionViewer(FactionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FactionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def ideology(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("ideology"))

    @property
    def territory(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("territory"))

    @property
    def influence_level(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("influence_level"))

    @property
    def relationships(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relationships"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class GetDistrictDetailsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GetDistrictDetails")
        self._properties: typing.Set[str] = set([ "tool_name",  "district_name", ])
        self._props = GetDistrictDetailsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GetDistrictDetailsProperties":
        return self._props


class GetDistrictDetailsViewer(GetDistrictDetailsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GetDistrictDetailsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def district_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("district_name"))

    

class GetFactionDetailsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GetFactionDetails")
        self._properties: typing.Set[str] = set([ "tool_name",  "faction_name", ])
        self._props = GetFactionDetailsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GetFactionDetailsProperties":
        return self._props


class GetFactionDetailsViewer(GetFactionDetailsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GetFactionDetailsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def faction_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("faction_name"))

    

class GetNPCDetailsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GetNPCDetails")
        self._properties: typing.Set[str] = set([ "tool_name",  "npc_name", ])
        self._props = GetNPCDetailsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GetNPCDetailsProperties":
        return self._props


class GetNPCDetailsViewer(GetNPCDetailsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GetNPCDetailsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def npc_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("npc_name"))

    

class GetTechnologyDetailsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GetTechnologyDetails")
        self._properties: typing.Set[str] = set([ "tool_name",  "technology_name", ])
        self._props = GetTechnologyDetailsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GetTechnologyDetailsProperties":
        return self._props


class GetTechnologyDetailsViewer(GetTechnologyDetailsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class GetTechnologyDetailsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def technology_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("technology_name"))

    

class ItemAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Item")
        self._properties: typing.Set[str] = set([ "id",  "name",  "type",  "description",  "effects",  "requirements",  "rarity",  "internal_hint",  "internal_justification", ])
        self._props = ItemProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ItemProperties":
        return self._props


class ItemViewer(ItemAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ItemProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def effects(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("effects"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def rarity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rarity"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class LocationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Location")
        self._properties: typing.Set[str] = set([ "id",  "name",  "type",  "description",  "traits",  "hazards",  "connected_locations",  "npcs_present",  "internal_hint",  "internal_justification", ])
        self._props = LocationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LocationProperties":
        return self._props


class LocationViewer(LocationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class LocationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("traits"))

    @property
    def hazards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hazards"))

    @property
    def connected_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("connected_locations"))

    @property
    def npcs_present(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("npcs_present"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class NPCAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NPC")
        self._properties: typing.Set[str] = set([ "id",  "name",  "role",  "description",  "personality_traits",  "relationships",  "faction_affiliations",  "location_id",  "internal_hint",  "internal_justification", ])
        self._props = NPCProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NPCProperties":
        return self._props


class NPCViewer(NPCAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class NPCProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def role(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("role"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def personality_traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("personality_traits"))

    @property
    def relationships(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relationships"))

    @property
    def faction_affiliations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("faction_affiliations"))

    @property
    def location_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("location_id"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class PlayerAttributeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerAttribute")
        self._properties: typing.Set[str] = set([ "id",  "type",  "description",  "stat_mods", ])
        self._props = PlayerAttributeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerAttributeProperties":
        return self._props


class PlayerAttributeViewer(PlayerAttributeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerAttributeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def stat_mods(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_mods"))

    

class PlayerProfileAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerProfile")
        self._properties: typing.Set[str] = set([ "narrative_summary",  "key_traits",  "background_hints", ])
        self._props = PlayerProfileProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerProfileProperties":
        return self._props


class PlayerProfileViewer(PlayerProfileAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerProfileProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def narrative_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("narrative_summary"))

    @property
    def key_traits(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_traits"))

    @property
    def background_hints(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("background_hints"))

    

class PlayerStateAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerState")
        self._properties: typing.Set[str] = set([ "name",  "stats",  "attributes",  "profile",  "history", ])
        self._props = PlayerStateProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerStateProperties":
        return self._props


class PlayerStateViewer(PlayerStateAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerStateProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def stats(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stats"))

    @property
    def attributes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes"))

    @property
    def profile(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("profile"))

    @property
    def history(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("history"))

    

class PlayerStatsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlayerStats")
        self._properties: typing.Set[str] = set([ "might",  "insight",  "nimbleness",  "destiny",  "savvy",  "expertise",  "tenacity",  "station",  "opulence",  "celebrity",  "integrity",  "allure",  "lineage", ])
        self._props = PlayerStatsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlayerStatsProperties":
        return self._props


class PlayerStatsViewer(PlayerStatsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlayerStatsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def might(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("might"))

    @property
    def insight(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("insight"))

    @property
    def nimbleness(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("nimbleness"))

    @property
    def destiny(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("destiny"))

    @property
    def savvy(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("savvy"))

    @property
    def expertise(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expertise"))

    @property
    def tenacity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tenacity"))

    @property
    def station(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("station"))

    @property
    def opulence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("opulence"))

    @property
    def celebrity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("celebrity"))

    @property
    def integrity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("integrity"))

    @property
    def allure(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("allure"))

    @property
    def lineage(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lineage"))

    

class QuestAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Quest")
        self._properties: typing.Set[str] = set([ "id",  "title",  "description",  "type",  "objectives",  "rewards",  "requirements",  "related_npcs",  "related_locations",  "internal_hint",  "internal_justification", ])
        self._props = QuestProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QuestProperties":
        return self._props


class QuestViewer(QuestAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QuestProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def objectives(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("objectives"))

    @property
    def rewards(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rewards"))

    @property
    def requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requirements"))

    @property
    def related_npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("related_npcs"))

    @property
    def related_locations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("related_locations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class ResumeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Resume")
        self._properties: typing.Set[str] = set([ "name",  "email",  "experience",  "skills", ])
        self._props = ResumeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResumeProperties":
        return self._props


class ResumeViewer(ResumeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResumeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def email(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("email"))

    @property
    def experience(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("experience"))

    @property
    def skills(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("skills"))

    

class SituationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Situation")
        self._properties: typing.Set[str] = set([ "id",  "description",  "player_perspective_description",  "choices",  "stat_requirements",  "consequences",  "bridgeable",  "context_tags",  "internal_hint",  "internal_justification", ])
        self._props = SituationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SituationProperties":
        return self._props


class SituationViewer(SituationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SituationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def player_perspective_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("player_perspective_description"))

    @property
    def choices(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("choices"))

    @property
    def stat_requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stat_requirements"))

    @property
    def consequences(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("consequences"))

    @property
    def bridgeable(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bridgeable"))

    @property
    def context_tags(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("context_tags"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class StatDescriptorsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StatDescriptors")
        self._properties: typing.Set[str] = set([ "might_descriptors",  "insight_descriptors",  "nimbleness_descriptors",  "destiny_descriptors",  "savvy_descriptors",  "expertise_descriptors",  "tenacity_descriptors",  "station_descriptors",  "opulence_descriptors",  "celebrity_descriptors",  "integrity_descriptors",  "allure_descriptors",  "lineage_descriptors", ])
        self._props = StatDescriptorsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StatDescriptorsProperties":
        return self._props


class StatDescriptorsViewer(StatDescriptorsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StatDescriptorsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def might_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("might_descriptors"))

    @property
    def insight_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("insight_descriptors"))

    @property
    def nimbleness_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("nimbleness_descriptors"))

    @property
    def destiny_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("destiny_descriptors"))

    @property
    def savvy_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("savvy_descriptors"))

    @property
    def expertise_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expertise_descriptors"))

    @property
    def tenacity_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tenacity_descriptors"))

    @property
    def station_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("station_descriptors"))

    @property
    def opulence_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("opulence_descriptors"))

    @property
    def celebrity_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("celebrity_descriptors"))

    @property
    def integrity_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("integrity_descriptors"))

    @property
    def allure_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("allure_descriptors"))

    @property
    def lineage_descriptors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lineage_descriptors"))

    

class StatRequirementAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StatRequirement")
        self._properties: typing.Set[str] = set([ "attribute_name",  "min_value", ])
        self._props = StatRequirementProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StatRequirementProperties":
        return self._props


class StatRequirementViewer(StatRequirementAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StatRequirementProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def attribute_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attribute_name"))

    @property
    def min_value(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("min_value"))

    

class TechnologyAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Technology")
        self._properties: typing.Set[str] = set([ "name",  "description",  "impact",  "limitations",  "internal_hint",  "internal_justification", ])
        self._props = TechnologyProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TechnologyProperties":
        return self._props


class TechnologyViewer(TechnologyAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TechnologyProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def impact(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("impact"))

    @property
    def limitations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("limitations"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    

class WorldConceptToolAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorldConceptTool")
        self._properties: typing.Set[str] = set([ "tool_name",  "description",  "parameters", ])
        self._props = WorldConceptToolProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorldConceptToolProperties":
        return self._props


class WorldConceptToolViewer(WorldConceptToolAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorldConceptToolProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tool_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_name"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def parameters(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("parameters"))

    

class WorldContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorldContext")
        self._properties: typing.Set[str] = set([ "seed",  "technologies",  "factions",  "districts",  "npcs",  "tension_sliders", ])
        self._props = WorldContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorldContextProperties":
        return self._props


class WorldContextViewer(WorldContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorldContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def seed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("seed"))

    @property
    def technologies(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("technologies"))

    @property
    def factions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factions"))

    @property
    def districts(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("districts"))

    @property
    def npcs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("npcs"))

    @property
    def tension_sliders(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tension_sliders"))

    

class WorldSeedAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorldSeed")
        self._properties: typing.Set[str] = set([ "name",  "themes",  "high_concept",  "internal_hint",  "internal_justification", ])
        self._props = WorldSeedProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorldSeedProperties":
        return self._props


class WorldSeedViewer(WorldSeedAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorldSeedProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("themes"))

    @property
    def high_concept(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("high_concept"))

    @property
    def internal_hint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_hint"))

    @property
    def internal_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("internal_justification"))

    




__all__ = ["TypeBuilder"]